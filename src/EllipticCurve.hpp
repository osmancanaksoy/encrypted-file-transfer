//EllipticCurve.hpp

namespace Cryptography
{
    /*
        Elliptic Curve over a finite field of order P:
        y^2 mod P = x^3 + ax + b mod P

        NOTE: this implementation is simple and uses normal machine integers for its calculations.
              No special "big integer" manipulation is supported so anything _big_ won't work.
              However, it is a complete finite field EC implementation in that it can be used
              to learn and understand the behaviour of these curves and in particular to experiment with them
              for their use in cryptography

        Template parameter P is the order of the finite field Fp over which this curve is defined
    */


    template<int P>
    class   EllipticCurve
    {
    public:
        // this curve is defined over the finite field (Galois field) Fp, this is the
        // typedef of elements in it
        typedef FiniteFieldElement<P> ffe_t;





        /*
            A point, or group element, on the EC, consisting of two elements of the field FP
            Points can only created by the EC instance itself as they have to be
            elements of the group generated by the EC
        */

        class   Point
        {
            friend  class   EllipticCurve<P>;
            typedef FiniteFieldElement<P> ffe_t;
            ffe_t  x_;
            ffe_t  y_;
            EllipticCurve* ec_;


            // core of the doubling multiplier algorithm (see below)
            // multiplies acc by m as a series of "2*acc's"
            void   addDouble(int m, Point& acc)
            {
                if (m > 0)
                {
                    Point r = acc;
                    for (int n = 0; n < m; ++n)
                    {
                        r += r;     // doubling step
                    }
                    acc = r;
                }
            }

            // doubling multiplier algorithm
            // multiplies a by k by expanding in multiplies by 2
            // a is also an accumulator that stores the intermediate results
            // between the "1s" of the binary form of the input scalar k
            Point scalarMultiply(int k, const Point& a)
            {
                Point acc = a;
                Point res = Point(0, 0, *ec_);
                int i = 0, j = 0;
                int b = k;

                while (b)
                {
                    if (b & 1)
                    {
                        // bit is set; acc = 2^(i-j)*acc
                        addDouble(i - j, acc);
                        res += acc;
                        j = i;  // last bit set
                    }
                    b >>= 1;
                    ++i;
                }
                return res;
            }
            // adding two points on the curve
            void    add(ffe_t x1, ffe_t y1, ffe_t x2, ffe_t y2, ffe_t& xR, ffe_t& yR) const
            {
                // special cases involving the additive identity
                if (x1 == 0 && y1 == 0)
                {
                    xR = x2;
                    yR = y2;
                    return;
                }
                if (x2 == 0 && y2 == 0)
                {
                    xR = x1;
                    yR = y1;
                    return;
                }
                if (y1 == -y2)
                {
                    xR = yR = 0;
                    return;
                }

                // the additions
                ffe_t s;
                if (x1 == x2 && y1 == y2)
                {
                    //2P
                    s = (3 * (x1.i() * x1.i()) + ec_->a()) / (2 * y1);
                    xR = ((s * s) - 2 * x1);
                }
                else
                {
                    //P+Q
                    s = (y1 - y2) / (x1 - x2);
                    xR = ((s * s) - x1 - x2);
                }

                if (s != 0)
                {
                    yR = (-y1 + s * (x1 - xR));
                }
                else
                {
                    xR = yR = 0;
                }
            }

            Point(int x, int y)
                : x_(x),
                y_(y),
                ec_(0)
            {}

            Point(int x, int y, EllipticCurve<P>& EllipticCurve)
                : x_(x),
                y_(y),
                ec_(&EllipticCurve)
            {}

            Point(const ffe_t& x, const ffe_t& y, EllipticCurve<P>& EllipticCurve)
                : x_(x),
                y_(y),
                ec_(&EllipticCurve)
            {}

        public:




            static  Point   ONE;

            Point() : x_(0), y_(0), ec_(nullptr) {}


            // copy ctor
            Point(const Point& rhs)
            {
                x_ = rhs.x_;
                y_ = rhs.y_;
                ec_ = rhs.ec_;
            }
            // assignment
            Point& operator=(const Point& rhs)
            {
                x_ = rhs.x_;
                y_ = rhs.y_;
                ec_ = rhs.ec_;
                return *this;
            }
            // access x component as element of Fp
            ffe_t x() const { return x_; }
            // access y component as element of Fp
            ffe_t y() const { return y_; }
            // calculate the order of this point by brute-force additions
            // WARNING: this can be VERY slow if the period is long and might not even converge
            // so maxPeriod should probably be set to something sensible...
            unsigned int     Order(unsigned int maxPeriod = ~0) const
            {
                Point r = *this;
                unsigned int n = 0;
                while (r.x_ != 0 && r.y_ != 0)
                {
                    ++n;
                    r += *this;
                    if (n > maxPeriod) break;
                }
                return n;
            }
            // negate
            Point   operator-()
            {
                return Point(x_, -y_);
            }
            // ==
            friend bool    operator==(const Point& lhs, const Point& rhs)
            {
                return (lhs.ec_ == rhs.ec_) && (lhs.x_ == rhs.x_) && (lhs.y_ == rhs.y_);
            }
            // !=
            friend bool    operator!=(const Point& lhs, const Point& rhs)
            {
                return (lhs.ec_ != rhs.ec_) || (lhs.x_ != rhs.x_) || (lhs.y_ != rhs.y_);
            }
            // a + b
            friend Point operator+(const Point& lhs, const Point& rhs)
            {
                ffe_t xR, yR;
                lhs.add(lhs.x_, lhs.y_, rhs.x_, rhs.y_, xR, yR);
                return Point(xR, yR, *lhs.ec_);
            }
            // a * int
            friend  Point operator*(int k, const Point& rhs)
            {
                return Point(rhs).operator*=(k);
            }
            // +=
            Point& operator+=(const Point& rhs)
            {
                add(x_, y_, rhs.x_, rhs.y_, x_, y_);
                return *this;
            }
            // a *= int
            Point& operator*=(int k)
            {
                return (*this = scalarMultiply(k, *this));
            }
            // ostream handler: print this point
            friend ostream& operator <<(ostream& os, const Point& p)
            {
                return (os << "(" << p.x_ << ", " << p.y_ << ")");
            }
        };


        // ==================================================== EllipticCurve impl
        //Point convertDBCoordinatesToPoint(int x, int y);
        typedef EllipticCurve<P> this_t;
        typedef EllipticCurve<P>::Point point_t;





        // ctor
        // Initialize EC as y^2 = x^3 + ax + b
        EllipticCurve(int a, int b)
            : a_(a),
            b_(b),
            m_table_(),
            table_filled_(false)
        {
        }
        // Calculate *all* the points (group elements) for this EC
        //NOTE: if the order of this curve is large this could take some time...
        void    CalculatePoints()
        {
            int x_val[P];
            int y_val[P];
            for (int n = 0; n < P; ++n)
            {
                int nsq = n * n;
                x_val[n] = ((n * nsq) + a_.i() * n + b_.i()) % P;
                y_val[n] = nsq % P;
            }

            for (int n = 0; n < P; ++n)
            {
                for (int m = 0; m < P; ++m)
                {
                    if (x_val[n] == y_val[m])
                    {
                        m_table_.push_back(Point(n, m, *this));
                    }
                }
            }

            table_filled_ = true;
        }
        // Get a point (group element) on the curve by index
        Point operator[](size_t index)
        {
            if (!table_filled_)
            {
                CalculatePoints();
            }

            if (index < m_table_.size())
            {
                return m_table_[index];
            }

            // Handle index out of bounds or table not filled
            // You can throw an exception, return a default value, or handle it as needed
            // For simplicity, let's return a default-initialized point
            //return Point();
        }
        // number of elements in this group
        size_t  Size() const { return m_table_.size(); }
        // the degree P of this EC
        int     Degree() const { return P; }
        // the parameter a (as an element of Fp)
        FiniteFieldElement<P>  a() const { return a_; }
        // the paramter b (as an element of Fp)
        FiniteFieldElement<P>  b() const { return b_; }

        // ostream handler: print this curve in human readable form
        template<int T>
        friend ostream& operator <<(ostream& os, const EllipticCurve<T>& EllipticCurve);
        // print all the elements of the EC group
        ostream& PrintTable(ostream& os, int columns = 4);

        Point convertDBCoordinatesToPoint(int x, int y)
        {
            if (x < 0 || x >= P || y < 0 || y >= P)
            {
                throw std::invalid_argument("Invalid coordinates for the Elliptic Curve.");
            }


            for (const Point& point : m_table_)
            {
                if (point.x().i() == x && point.y().i() == y)
                {
                    return point;
                }
            }

            throw std::invalid_argument("Point with given coordinates not found on the Elliptic Curve.");
        }




    private:
        typedef std::vector<Point>  m_table_t;

        m_table_t                   m_table_;   // table of points
        FiniteFieldElement<P>       a_;         // paramter a of the EC equation
        FiniteFieldElement<P>       b_;         // parameter b of the EC equation
        bool    table_filled_;                  // true if the table has been calculated
    };



    template<int T>
    typename EllipticCurve<T>::Point EllipticCurve<T>::Point::ONE(0, 0);





    template<int T>
    ostream& operator <<(ostream& os, const EllipticCurve<T>& EllipticCurve)
    {
        os << "y^2 mod " << T << " = (x^3" << showpos;
        if (EllipticCurve.a_ != 0)
        {
            os << EllipticCurve.a_ << "x";
        }

        if (EllipticCurve.b_.i() != 0)
        {
            os << EllipticCurve.b_;
        }

        os << noshowpos << ") mod " << T;
        return os;
    }

    template<int P>
    ostream& EllipticCurve<P>::PrintTable(ostream& os, int columns)
    {
        if (table_filled_)
        {
            int col = 0;
            typename EllipticCurve<P>::m_table_t::iterator iter = m_table_.begin();
            for (; iter != m_table_.end(); ++iter)
            {
                os << "(" << (*iter).x_.i() << ", " << (*iter).y_.i() << ") ";
                if (++col > columns)
                {
                    os << "\n";
                    col = 0;
                }
            }
        }
        else
        {
            os << "EllipticCurve, F_" << P;
        }
        return os;
    }

    namespace   utils
    {
       inline float   frand()
        {
            static float norm = 1.0f / (float)RAND_MAX;
            return (float)rand() * norm;
        }

       inline int irand(int min, int max)
        {
            return min + (int)(frand() * (float)(max - min));
        }




    }

    namespace operations
    {
        static int generatePrivateKey(const EllipticCurve<263>& curve) {
            return utils::irand(1, curve.Degree() - 1);
        }

        // Function to generate a public key from a private key
        static EllipticCurve<263>::Point generatePublicKey(int privateKey, EllipticCurve<263>& curve) {
            return privateKey * curve[0];
        }

        // Function to perform encryption
        static std::string encryptMessage(const std::string& plaintext, const EllipticCurve<263>::Point& publicKey) {
            std::string ciphertext;
            for (char c : plaintext) {
                EllipticCurve<263>::ffe_t encrypted_char = c * publicKey.x();
                ciphertext += std::to_string(encrypted_char.i()) + "-";
            }
            return ciphertext;
        }

        // Function to perform decryption
        static std::string decryptMessage(const std::string& ciphertext, const EllipticCurve<263>::Point& privateKeyPoint) {
            std::string decrypted_text;
            std::istringstream iss(ciphertext);
            std::string token;
            while (std::getline(iss, token, '-')) {
                int encrypted_char = std::stoi(token);
                EllipticCurve<263>::ffe_t decrypted_char = encrypted_char / privateKeyPoint.x();
                decrypted_text += static_cast<char>(decrypted_char.i());
            }
            return decrypted_text;
        }

        // Function to read text from a file
        static std::string readFile(const std::string& fileName) {
            std::ifstream file(fileName);
            if (file.is_open()) {
                std::stringstream buffer;
                buffer << file.rdbuf();
                file.close();
                return buffer.str();
            }
            throw std::runtime_error("Unable to open file: " + fileName);
        }

        // Function to write text to a file
        static void writeFile(const std::string& fileName, const std::string& content) {
            std::ofstream file(fileName);
            if (file.is_open()) {
                file << content;
                file.close();
            }
            else {
                throw std::runtime_error("Unable to open file for writing: " + fileName);
            }
        }

        static void writeKeysToFile(const std::string& fileName, int privateKeyPoint, const EllipticCurve<263>::Point& publicKeyPoint) {
            std::ofstream file(fileName);
            if (file.is_open()) {
                //file << "Private Key: " << privateKeyPoint << "\n";
                file << publicKeyPoint << "\n";
                file.close();
            }
            else {
                throw std::runtime_error("Unable to open file for writing: " + fileName);
            }
        }



    }

}





